<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra Engine v2.5 Professional</title>
    <style>
        :root {
            --bg: #020617;
            --panel: rgba(15, 23, 42, 0.9);
            --node: #1e293b;
            --accent: #38bdf8;
            --wall: #0f172a;
            --visited: rgba(56, 189, 248, 0.35);
            --path: #facc15;
            --wall-border: #334155;
        }

        body {
            margin: 0; background: var(--bg); color: #f8fafc;
            font-family: 'Fira Code', monospace;
            display: flex; flex-direction: column; height: 100vh; overflow: hidden;
            user-select: none;
        }

        .header {
            padding: 15px 25px; background: var(--panel); backdrop-filter: blur(15px);
            border-bottom: 1px solid rgba(56, 189, 248, 0.2);
            display: flex; justify-content: space-between; align-items: center; z-index: 100;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .controls { display: flex; gap: 15px; align-items: center; }

        .stats { display: flex; gap: 20px; font-size: 13px; color: var(--accent); }
        .stats b { color: #fff; }

        button {
            padding: 10px 18px; border: 1px solid var(--accent); border-radius: 4px;
            background: transparent; color: var(--accent); cursor: pointer;
            font-weight: bold; font-size: 12px; text-transform: uppercase; transition: 0.2s;
        }

        button:hover { background: var(--accent); color: var(--bg); box-shadow: 0 0 15px var(--accent); }
        .btn-maze { border-color: #a855f7; color: #a855f7; }
        .btn-maze:hover { background: #a855f7; color: white; box-shadow: 0 0 15px #a855f7; }

        #grid {
            display: grid; flex-grow: 1; padding: 10px; gap: 2px;
            background: var(--bg); touch-action: none;
        }

        .node {
            background: var(--node); border-radius: 1px;
            transition: background 0.2s, transform 0.1s;
        }

        .node:hover { background: #334155; z-index: 2; outline: 1px solid var(--accent); }

        /* Состояния */
        .node-wall { 
            background: var(--wall) !important; 
            border: 1px solid var(--wall-border);
            animation: wallPop 0.2s ease-out;
        }
        @keyframes wallPop { 0% { transform: scale(0.5); } 100% { transform: scale(1); } }

        .node-start { background: #22c55e !important; box-shadow: 0 0 15px #22c55e; border-radius: 4px; }
        .node-end { background: #ef4444 !important; box-shadow: 0 0 15px #ef4444; border-radius: 4px; }
        
        .node-visited { animation: visitedDiscovery 0.5s ease-out forwards; }
        .node-path { background: var(--path) !important; box-shadow: 0 0 20px var(--path); z-index: 5; }

        @keyframes visitedDiscovery {
            0% { transform: scale(0.5); background: #6366f1; opacity: 0; }
            100% { transform: scale(1); background: var(--visited); opacity: 1; }
        }

        .label { font-size: 11px; color: #94a3b8; margin-bottom: 5px; text-transform: uppercase; }
    </style>
</head>
<body>

<div class="header">
    <div class="controls">
        <div>
            <span class="label">Действие</span>
            <button onclick="visualize()">Start Engine</button>
            <button class="btn-maze" onclick="generateRandomMaze()">Auto Maze</button>
            <button style="border-color: #64748b; color: #94a3b8;" onclick="location.reload()">Reset</button>
        </div>
        <div>
            <span class="label">Speed: <span id="speed-val">30</span>ms</span>
            <input type="range" id="speed" min="1" max="150" value="30" oninput="document.getElementById('speed-val').innerText = this.value">
        </div>
    </div>
    
    <div class="stats">
        <div>Visited: <b id="s-visited">0</b></div>
        <div>Distance: <b id="s-path">0</b></div>
    </div>
</div>

<div id="grid"></div>

<script>
    const GRID_SIZE_X = Math.floor(window.innerWidth / 28);
    const GRID_SIZE_Y = Math.floor((window.innerHeight - 100) / 28);
    let nodes = [];
    let isMouseDown = false;
    let startNode = { x: 4, y: Math.floor(GRID_SIZE_Y/2) };
    let endNode = { x: GRID_SIZE_X - 5, y: Math.floor(GRID_SIZE_Y/2) };

    function createGrid() {
        const gridEl = document.getElementById('grid');
        gridEl.style.gridTemplateColumns = `repeat(${GRID_SIZE_X}, 1fr)`;

        for (let y = 0; y < GRID_SIZE_Y; y++) {
            nodes[y] = [];
            for (let x = 0; x < GRID_SIZE_X; x++) {
                const el = document.createElement('div');
                el.className = 'node';
                
                if (x === startNode.x && y === startNode.y) el.classList.add('node-start');
                if (x === endNode.x && y === endNode.y) el.classList.add('node-end');

                // Обработка рисования и удаления
                el.onmousedown = (e) => {
                    e.preventDefault();
                    isMouseDown = true;
                    toggleWall(x, y);
                };
                el.onmouseenter = () => { if(isMouseDown) toggleWall(x, y); };
                el.ondblclick = () => removeWall(x, y);

                gridEl.appendChild(el);
                nodes[y][x] = { x, y, isWall: false, distance: Infinity, previous: null, element: el };
            }
        }
    }

    function toggleWall(x, y) {
        if ((x==startNode.x && y==startNode.y) || (x==endNode.x && y==endNode.y)) return;
        const node = nodes[y][x];
        node.isWall = true;
        node.element.classList.add('node-wall');
    }

    function removeWall(x, y) {
        const node = nodes[y][x];
        node.isWall = false;
        node.element.classList.remove('node-wall');
    }

    function generateRandomMaze() {
        for(let y=0; y<GRID_SIZE_Y; y++) {
            for(let x=0; x<GRID_SIZE_X; x++) {
                if(Math.random() < 0.25) toggleWall(x, y);
            }
        }
    }

    window.onmouseup = () => isMouseDown = false;

    async function visualize() {
        let visitedCount = 0;
        const speed = parseInt(document.getElementById('speed').value);
        let unvisited = [];
        
        for (let row of nodes) {
            for (let n of row) {
                n.distance = Infinity; n.previous = null;
                n.element.classList.remove('node-visited', 'node-path');
                unvisited.push(n);
            }
        }
        nodes[startNode.y][startNode.x].distance = 0;

        while (unvisited.length > 0) {
            unvisited.sort((a, b) => a.distance - b.distance);
            let current = unvisited.shift();

            if (current.isWall || current.distance === Infinity) continue;

            if (current.x === endNode.x && current.y === endNode.y) {
                drawPath(current);
                return;
            }

            if (!(current.x === startNode.x && current.y === startNode.y)) {
                current.element.classList.add('node-visited');
                visitedCount++;
                document.getElementById('s-visited').innerText = visitedCount;
            }

            const neighbors = getNeighbors(current);
            for (let neighbor of neighbors) {
                let alt = current.distance + 1;
                if (alt < neighbor.distance) {
                    neighbor.distance = alt;
                    neighbor.previous = current;
                }
            }
            if(speed > 0) await new Promise(r => setTimeout(r, speed));
        }
    }

    function getNeighbors(n) {
        let res = [];
        if (n.y > 0) res.push(nodes[n.y-1][n.x]);
        if (n.y < GRID_SIZE_Y-1) res.push(nodes[n.y+1][n.x]);
        if (n.x > 0) res.push(nodes[n.y][n.x-1]);
        if (n.x < GRID_SIZE_X-1) res.push(nodes[n.y][n.x+1]);
        return res;
    }

    async function drawPath(end) {
        let pathLength = 0;
        let temp = end;
        while (temp.previous) {
            temp.element.classList.add('node-path');
            temp = temp.previous;
            pathLength++;
            document.getElementById('s-path').innerText = pathLength;
            await new Promise(r => setTimeout(r, 20));
        }
    }

    createGrid();
</script>
</body>
</html>
